<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>sass基础知识梳理</title>
	<link rel="stylesheet" href="css/base.css" />

</head>
<body>
	<p>1、在sass的大多数地方，中划线命名和下划线命名的内容是互通的，除了变量，也包括对混合器和Sass函数的命名。但是在sass中纯css部分不互通，比如类名、ID或属性名。</p>
	<p>2、如果想要在嵌套的选择器里边立刻应用一个类似于:hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构&。在使用嵌套规则时，父选择器能对于嵌套规则如何解开提供更好的控制。它就是一个简单的&符号，且可以放在任何一个选择器可出现的地方。</p>
	<p>3、处理群组选择器规则嵌套上的强大能力，正是sass在减少重复敲写方面的贡献之一。尤其在当嵌套级别达到两层甚至三层以上时，与普通的css编写方式相比，只写一遍群组选择器大大减少了工作量。</p>
	<p>4、在sass中，不仅仅css规则可以嵌套，对属性进行嵌套也可以减少很多重复性的工作。尽管编写属性涉及的重复不像编写选择器那么糟糕，但是要反复写也是非常烦人的。嵌套属性的规则是这样的：把属性名从中划线—的地方断开，在根属性后边添加一个冒号：，紧跟一个{}块，把子属性部分写在这个{}块中。就像css选择器嵌套一样，sass会把你的子属性一一解开，把根属性和子属性部分通过中划线－连接起来。</p>
	<p>5、css有一个特别不常用的特性，即@import规则，它允许在一个css文件中导入其他css文件。然而，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。sass也有一个@import规则，但不同的是，sass的@import规则在生成css文件时就把相关文件导入进来。 使用sass的@import规则并不需要指明被导入文件的全名，你可以省略.sass或.scss文件后缀。sass局部文件的文件名以下划线开头，这样，sass就不会再编译时单独编译这个文件输出css，而只把这个文件用作导入。当你@import一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。局部文件可以被多个不同的文件引用。当一些样式需要在多个页面甚至多个项目中使用时，这非常有用。 </p>
	<p>6、假如你写了一个可被他人通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值。使用sass的!default标签可以实现这个目的。它很像css属性中!important标签的对立面，不同的是!default用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。文件导入是保证sass的代码的可维护性和可读性的重要一环。</p>
	<p>7、静默注释（其内容不会出现在生成的css文件中）：它们以//开头，注释内容直到行末。</p>
	<p>8、保持sass条理性和可读性的最基本的三个方法：嵌套、导入和注释。</p>
	<p>9、混合器：可以通过sass的混合器实现大段样式的重用。混合器使用@mixin标识符定义.通过@include来使用这个混合器，放在你希望的任何地方。@include调用会把混合器中的所有样式提取出来放在@include被调用的地方。混合器大量的重用可能会导致生成的样式表过大，导致加载缓慢，注意混合气的使用场景，避免滥用。利用混合器，可以很容易地在样式表的不同地方共享样式。如果你发现自己在不停地重复一段样式，那就应该把这段样式构造成优良的混合器，尤其是这段样式本身就是一个逻辑单元，比如说是一组放在一起有意义的属性。判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。混合器在某些方面跟css类很像。都是让你给一大段样式命名，所以在选择使用哪个的时候可能会产生疑惑。最重要的区别就是类名是在html文件中应用的，而混合器是在样式表中应用的。这就意味着类名具有语义化含义，而不仅仅是一种展示性的描述：用来描述html元素的含义而不是html元素的外观。而另一方面，混合器是展示性的描述，用来描述一条css规则应用之后会产生怎样的效果。</p>
	<p>9-1、混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性。混合器中的规则甚至可以使用sass的父选择器标识符&。使用起来跟不用混合器时一样，sass解开嵌套规则时，用父规则中的选择器替代&。如果一个混合器只包含css规则，不包含属性，那么这个混合器就可以在文档的顶部调用，写在所有的css规则之外。</p>
	<p>9-2、给混合器传参：混合器并不一定生成相同的样式。可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式。当&include混合器时，参数其实可以赋值给css属性值的变量。如果你写过javascript，这种方式跟javascript的function很像。sass允许混合气声明时给参数赋默认值。混合器只是sass样式重用特性中的一个，混合器主要用于样式展示层的重用，如果想重用语义化的类就涉及sass的另一个重要的重用特性：选择器继承。</p>
	<p>10、使用sass的时候，最后一个减少重复的主要特性就是选择器继承，选择器继承是说一个选择器可以继承另一个选择器定义的所有样式，这个通过@extend语法实现。混合器主要用于展示性样式的重用，而类名用于语义化样式的重用。因为继承是基于类的（有时是基于其他类型的选择器），所以继承应该是建立在语义化的关系上。当一个元素拥有的类表明它是属于另一个类，这时使用继承再合适不过了。使用sass时，我们提倡的就是不要做重复的工作。</p>
	<p>10-1、继承的高级用法：任何css规则都可以继承其他规则，几乎任何css规则都可以继承。</p>
	<p>10-2、继承的工作细节：跟变量和混合器不同，继承不是仅仅用css样式替换@extend处的代码那么简单。跟混合器相比，继承生成的css代码相对更少。因为基恒仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。继承遵从css层叠的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，css层叠规则会决定应用哪个样式。相当直观，通常权重最高的选择器胜出，如果权重相同，定义在后边的规则胜出。混合器本身不会引起css层叠的问题，因为混合器把样式直接放到了css规则中，而继承存在样式层叠的问题。被继承的样式会保持原有定义位置和选择器权重不变。</p>
	<p>10-3、通常使用继承会让你的css美观、整洁。因为继承只会在生成css时复制选择器，而不会复制大段的css属性。但是如果你不小心，可能会让生成的css中包含大量的选择器复制。避免这种情况出现的最好方法就是不要在css规则中使用后代选择器。如果你这么做，同时被继承的css规则有通过后代选择器修饰的样式，生成css中的选择器的数量很快就会失控。你完全可以放心地继承有后代选择器修饰规则的选择器，不管后代选择器多长，但有一个前提就是，不要用后代选择器去继承。</p>
	<p>变量是sass提供的最基本的工具。通过变量可以让独立的css值变得可重用，无论是在一条单独的规则范围内还是在整个样式表中。变量、混合器的命名甚至sass的文件名，可以互换通用_和—。同样基础的是sass的嵌套机制。嵌套允许css规则内嵌套css规则，减少重复编写常用的选择器，同时让样式表的结构一眼望去更加清晰。sass同时提供了特殊的父选择器标识符&，通过它可以构造出更高效的嵌套。通过样式导入可以把分散在多个sass文件中的内容合并生成到一个css文件，避免了项目中有大量的css文件通过原生的css @import带来的性能问题。通过嵌套导入和默认变量值，导入可以构建更强有力的、可定制的样式。混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。</p>
</body>
</html>