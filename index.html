<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>个人主页</title>
	<link rel="stylesheet" href="css/base.css" />

</head>
<body>
	<p>1、在sass的大多数地方，中划线命名和下划线命名的内容是互通的，除了变量，也包括对混合器和Sass函数的命名。但是在sass中纯css部分不互通，比如类名、ID或属性名。</p>
	<p>2、如果想要在嵌套的选择器里边立刻应用一个类似于:hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结构&。在使用嵌套规则时，父选择器能对于嵌套规则如何解开提供更好的控制。它就是一个简单的&符号，且可以放在任何一个选择器可出现的地方。</p>
	<p>3、处理群组选择器规则嵌套上的强大能力，正是sass在减少重复敲写方面的贡献之一。尤其在当嵌套级别达到两层甚至三层以上时，与普通的css编写方式相比，只写一遍群组选择器大大减少了工作量。</p>
	<p>4、在sass中，不仅仅css规则可以嵌套，对属性进行嵌套也可以减少很多重复性的工作。尽管编写属性涉及的重复不像编写选择器那么糟糕，但是要反复写也是非常烦人的。嵌套属性的规则是这样的：把属性名从中划线—的地方断开，在根属性后边添加一个冒号：，紧跟一个{}块，把子属性部分写在这个{}块中。就像css选择器嵌套一样，sass会把你的子属性一一解开，把根属性和子属性部分通过中划线－连接起来。</p>
	<p>5、css有一个特别不常用的特性，即@import规则，它允许在一个css文件中导入其他css文件。然而，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。sass也有一个@import规则，但不同的是，sass的@import规则在生成css文件时就把相关文件导入进来。 使用sass的@import规则并不需要指明被导入文件的全名，你可以省略.sass或.scss文件后缀。 </p>
	<p>6、假如你写了一个可被他人通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值。使用sass的!default标签可以实现这个目的。它很像css属性中!important标签的对立面，不同的是!default用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。</p>
	<p>7、静默注释：它们以//开头，注释内容直到行末。</p>
	<p>8、保持sass条理性和可读性的最基本的三个方法：嵌套、导入和注释。</p>
	<p>9、混合器：可以通过sass的混合器实现大段样式的重用。混合器使用@mixin标识符定义.通过@include来使用这个混合器，放在你希望的任何地方。@include调用会把混合器中的所有样式提取出来放在@include被调用的地方。混合器大量的重用可能会导致生成的样式表过大，导致加载缓慢，注意混合气的使用场景，避免滥用。利用混合器，可以很容易地在样式表的不同地方共享样式。如果你发现自己在不停地重复一段样式，那就应该把这段样式构造成优良的混合器，尤其是这段样式本身就是一个逻辑单元，比如说是一组放在一起有意义的属性。判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。混合器在某些方面跟css类很像。都是让你给一大段样式命名，所以在选择使用哪个的时候可能会产生疑惑。最重要的区别就是类名是在html文件中应用的，而混合器是在样式表中应用的。这就意味着类名具有语义化含义，而不仅仅是一种展示性的描述：用来描述html元素的含义而不是html元素的外观。而另一方面，混合器是展示性的描述，用来描述一条css规则应用之后会产生怎样的效果。</p>
	<p>9-1、混合器中不仅可以包含属性，也可以包含css规则，包含</p>
</body>
</html>